<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Particle advection · SpeedyWeather.jl</title><meta name="title" content="Particle advection · SpeedyWeather.jl"/><meta property="og:title" content="Particle advection · SpeedyWeather.jl"/><meta property="twitter:title" content="Particle advection · SpeedyWeather.jl"/><meta name="description" content="Documentation for SpeedyWeather.jl."/><meta property="og:description" content="Documentation for SpeedyWeather.jl."/><meta property="twitter:description" content="Documentation for SpeedyWeather.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpeedyWeather.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../barotropic/">Barotropic model</a></li><li><a class="tocitem" href="../shallowwater/">Shallow water model</a></li><li><a class="tocitem" href="../primitiveequation/">Primitive equation model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../large_scale_condensation/">Large-scale condensation</a></li><li><a class="tocitem" href="../convection/">Convection</a></li><li><a class="tocitem" href="../radiation/">Radiation</a></li><li><a class="tocitem" href="../vertical_diffusion/">Vertical diffusion</a></li><li><a class="tocitem" href="../surface_fluxes/">Surface fluxes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Discretization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../spectral_transform/">Spherical Harmonic Transform</a></li><li><a class="tocitem" href="../grids/">Grids</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Running SpeedyWeather</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../how_to_run_speedy/">How to run SpeedyWeather</a></li><li><a class="tocitem" href="../examples_2D/">Examples 2D</a></li><li><a class="tocitem" href="../examples_3D/">Examples 3D</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../structure/">Tree structure</a></li><li class="is-active"><a class="tocitem" href>Particle advection</a><ul class="internal"><li><a class="tocitem" href="#Discretization-of-particle-advection"><span>Discretization of particle advection</span></a></li><li><a class="tocitem" href="#Create-a-particle"><span>Create a particle</span></a></li><li><a class="tocitem" href="#Advecting-particles"><span>Advecting particles</span></a></li><li><a class="tocitem" href="#Tracking-particles"><span>Tracking particles</span></a></li></ul></li><li><a class="tocitem" href="../output/">NetCDF output</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Extending SpeedyWeather</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../forcing_drag/">Forcing and drag</a></li><li><a class="tocitem" href="../parameterizations/">Parameterizations</a></li><li><a class="tocitem" href="../orography/">Orography</a></li><li><a class="tocitem" href="../land_sea_mask/">Land-Sea Mask</a></li><li><a class="tocitem" href="../ocean/">Ocean</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li></ul></li><li><a class="tocitem" href="../ringgrids/">RingGrids</a></li><li><a class="tocitem" href="../lowertriangularmatrices/">LowerTriangularMatrices</a></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">SpeedyTransforms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../speedytransforms/">Spectral transforms</a></li><li><a class="tocitem" href="../gradients/">Gradient operators</a></li></ul></li><li><a class="tocitem" href="../functions/">Function and type index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Running SpeedyWeather</a></li><li class="is-active"><a href>Particle advection</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Particle advection</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SpeedyWeather/SpeedyWeather.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/main/docs/src/particles.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Particle-advection"><a class="docs-heading-anchor" href="#Particle-advection">Particle advection</a><a id="Particle-advection-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-advection" title="Permalink"></a></h1><p>All SpeedyWeather.jl models support particle advection. Particles are objects without mass or volume at a location <span>$\mathbf{x} = (\lambda, \theta, \sigma)$</span> (longitude <span>$\lambda$</span>, latitude <span>$\theta$</span>, vertical sigma coordinate <span>$\sigma$</span>, see <a href="../primitiveequation/#Sigma-coordinates">Sigma coordinates</a>) that are moved with the wind <span>$\mathbf{u}(\mathbf{x})$</span> at that location. The location of the <span>$p$</span>-th particle changes as follows</p><p class="math-container">\[\frac{d \mathbf{x}_p}{d t} = \mathbf{u}(\mathbf{x}_p)\]</p><p>This equation applies in 2D, i.e. <span>$\mathbf{x} = (\lambda, \theta)$</span> and <span>$\mathbf{u} = (u, v)$</span> or in 3D, but at the moment only 2D advection is supported. In the <a href="../primitiveequation/#primitive_equation_model">Primitive equation model</a> the vertical layer on which the advection takes place has to be specified. It is therefore not advected with the vertical velocity but maintains a constant pressure ratio compared to the surface pressure (<span>$\sigma$</span> is constant).</p><h2 id="Discretization-of-particle-advection"><a class="docs-heading-anchor" href="#Discretization-of-particle-advection">Discretization of particle advection</a><a id="Discretization-of-particle-advection-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization-of-particle-advection" title="Permalink"></a></h2><p>The particle advection equation has to be discretized to be numerically solved. While the particle location can generally be anywhere on the sphere, the velocity <span>$\mathbf{u}$</span> is only available on the discrete grid points of the simulation, such that <span>$\mathbf{u}(\mathbf{x}_p)$</span> requires an interpolation in order to obtain a velocity at the particles location <span>$\mathbf{x}_p$</span> to move it around. Dropping the subscript <span>$p$</span> in favour a subscript <span>$i$</span> denoting the time step, with Euler forward  the equation can be discretized as </p><p class="math-container">\[\mathbf{x}_{i+1} = \mathbf{x}_i + \Delta t~\mathbf{u}_i (\mathbf{x}_i)\]</p><p>Meaning we have used the velocity field at both departure time <span>$i$</span> and departure location <span>$\mathbf{x}_i$</span> to update a particle&#39;s location which makes this scheme first order accurate. But only a single interpolation of the velocity field, which, in fact, is one per dimension, is necessary. Note that the time step <span>$\Delta t$</span> here and the time step to solve the dynamics do not have to be identical. We could use a larger time step for the particle advection then to solve the dynamics inside the model, and because the stability criteria for these equations are different, one is encouraged to do so. Also because the particles are considered passive, meaning that their location does not influence the other prognostic variables.</p><p>We can write down a more accurate scheme at the cost of a second interpolation step. The Heun method, also called predictor-corrector is 2nd order accurate and uses an average of the velocity at departure time <span>$i$</span> and location <span>$\mathbf{x}_i$</span> and at a (<em>predicted</em> meaning preliminary) arrival point <span>$x^\star_{i+1}$</span> and arrival time <span>$i+1$</span>.</p><p class="math-container">\[\begin{aligned}
\mathbf{x}^\star_{i+1} &amp;= \mathbf{x}_i + \Delta t~\mathbf{u}_i (\mathbf{x}_i) \\
\mathbf{x}_{i+1} &amp;= \mathbf{x}_i + \frac{\Delta t}{2}~\left(
    \mathbf{u}_i (\mathbf{x}_i) + \mathbf{u}_{i+1} (\mathbf{x}^\star_{i+1})\right)
\end{aligned}\]</p><p>Because we don&#39;t have <span>$\mathbf{u}_{i+1}$</span> available at time <span>$i$</span>, we perform this integration retrospectively, i.e. if the other model dynamics have reached time <span>$i+1$</span> then we let the particle advection catch up by integrating them from <span>$i$</span> to <span>$i+1$</span>. This, however, requires some storage of the velocity <span>$\mathbf{u}_i$</span> at the previous advection time step. Remember that this does not need to be the time step for the momentum equations and could be much further in the past. We could either store <span>$\mathbf{u}_i$</span> as a grid-point field or only its interpolated values. In the case of fewer particles than grid points the latter is more efficient and this is also what we do in SpeedyWeather. Let square brackets <span>$[]$</span> denote an interpolation then we perform the interpolation <span>$\mathbf{u}_i [\mathbf{x}_i]$</span> that&#39;s required to step from <span>$i$</span> to <span>$i+1$</span> already on the time step that goes from <span>$i-1$</span> to <span>$i$</span>. </p><p class="math-container">\[\begin{aligned}
\mathbf{x}^\star_{i+1} &amp;= \mathbf{x}_i + \Delta t~\mathbf{u}_i (\mathbf{x}_i) \\
\mathbf{x}_{i+1} &amp;= \mathbf{x}_i + \frac{\Delta t}{2}~\left(
    \mathbf{u}_i (\mathbf{x}_i) + \mathbf{u}_{i+1} [\mathbf{x}^\star_{i+1}]\right) \\
\mathbf{u}_{i+1} (\mathbf{x}_{i+1}) &amp;=  \mathbf{u}_{i+1} [\mathbf{x}_{i+1}]
\end{aligned}\]</p><p>Denoted here as the last line with the left-hand side becoming the last term of the first line in the next time step <span>$i+1 \to i+2$</span>. Now it becomes clearer that there are two interpolations required on every time step.</p><p>We use for horizontal coordinates degrees, such that we need to scale the time step <span>$\Delta$</span> with <span>$\frac{360˚}{2\pi R}$</span> (radius <span>$R$</span>) for advection in latitude and with <span>$\frac{360˚}{2\pi R \cos(\theta)}$</span> for advection in longitude (because the distance between meridians decreases towards the poles). We move the division by the radius conveniently into the time step as are also the momentum equations scaled with the radius, see <a href="../barotropic/#scaling">Radius scaling</a>.</p><p>Technically, a particle moved with a given velocity follows a <a href="https://en.wikipedia.org/wiki/Great-circle_distance">great circle</a> in spherical coordinates. This means that</p><p class="math-container">\[\theta_{i+1} \approx \theta_i + \frac{\Delta t}{R} \frac{360}{2\pi} v_i\]</p><p>becomes a bad approximation when the time step and or the velocity are large. However, for simplicity and to avoid the calculation of the great circle we currently do use this to move particles with a given velocity. We essentially assume a local cartesian coordinate system instead of the geodesics in spherical coordinates. However, for typical time steps of 1 hour and velocities not exceeding 100 m/s the error is not catastrophic and can be reduced with a shorter time step. We may switch to great circle calculations in future versions.</p><h2 id="Create-a-particle"><a class="docs-heading-anchor" href="#Create-a-particle">Create a particle</a><a id="Create-a-particle-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-particle" title="Permalink"></a></h2><p>So much about the theory</p><p>A <a href="../functions/#SpeedyWeather.Particle"><code>Particle</code></a> at location 10˚E and 30˚N (and <span>$\sigma = 0$</span>) can be created as follows,</p><pre><code class="language-julia hljs">using SpeedyWeather
p = Particle(lon=10, lat=30, σ=0)
p = Particle(lon=10, lat=30)
p = Particle(10, 30, 0)
p = Particle(10, 30)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Particle{Float32,   active}( 10.00˚E,  30.00˚N, σ = 0.00)</code></pre><p>All of the above are equivalent. Unless a keyword argument is used, longitude is the first argument, followed by latitude (necessary), followed by <span>$\sigma$</span> (can be omitted). Longitudes can be -180˚E to 180˚E or 0 to 360˚E, latitudes have to be -90˚N to 90˚N. You can create a particle with coordinates outside of these ranges (and no error or warning is thrown) but during particle advection they will be wrapped into [0, 360˚E] and [-90˚N, 90˚N], using the <a href="../functions/#Base.mod-Tuple{P} where P&lt;:Particle"><code>mod(::Particle)</code></a> function, which is similar to the modulo operator but with the second argument hardcoded to the coordinate ranges from above, e.g.</p><pre><code class="language-julia hljs">mod(Particle(lon=-30, lat=0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Particle{Float32,   active}(330.00˚E,   0.00˚N, σ = 0.00)</code></pre><p>which also takes into account pole crossings which adds 180˚ in longitude</p><pre><code class="language-julia hljs">mod(Particle(lon=0, lat=100))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Particle{Float32,   active}(180.00˚E,  80.00˚N, σ = 0.00)</code></pre><p>as if the particle has moved across the pole. That way all real values for longitude and latitude are wrapped into the reference range [0, 360˚E] and [-90˚N, 90˚N].</p><div class="admonition is-info"><header class="admonition-header">Particles are immutable</header><div class="admonition-body"><p>Particles are implemented as immutable <code>struct</code>, meaning you cannot change their position by <code>particle.lon = value</code>. You have to think of them as integers or floats instead. If you have a particle <code>p</code> and you want to change its position to the Equator for example you need to create a new one <code>new_particle = Particle(p.lon, 0, p.σ)</code>.</p></div></div><p>By default <code>Float32</code> is used, but providing coordinates in <code>Float64</code> will promote the type accordingly. Also by default, particles are <em>active</em> which is indicated by the 2nd parametric type of <code>Particle</code>, a boolean. Active particles are moved following the equation above, but inactive particles are not. You can <a href="../functions/#SpeedyWeather.activate-Union{Tuple{Particle{NF}}, Tuple{NF}} where NF"><code>activate</code></a> or <a href="../functions/#SpeedyWeather.deactivate-Union{Tuple{Particle{NF}}, Tuple{NF}} where NF"><code>deactivate</code></a> a particle like so</p><pre><code class="language-julia hljs">deactivate(p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Particle{Float32, inactive}( 10.00˚E,  30.00˚N, σ = 0.00)</code></pre><p>and so</p><pre><code class="language-julia hljs">activate(p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Particle{Float32,   active}( 10.00˚E,  30.00˚N, σ = 0.00)</code></pre><p>or check its activity by <a href="../functions/#SpeedyWeather.active-Union{Tuple{Particle{NF, isactive}}, Tuple{isactive}, Tuple{NF}} where {NF, isactive}"><code>active(::Particle)</code></a> returning <code>true</code> or <code>false</code>. The zero-element of the <a href="../functions/#SpeedyWeather.Particle"><code>Particle</code></a> type is</p><pre><code class="language-julia hljs">zero(Particle)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Particle{Float32,   active}(  0.00˚E,   0.00˚N, σ = 0.00)</code></pre><p>and you can also create a random particle which uses a <a href="https://en.wikipedia.org/wiki/Raised_cosine_distribution">raised cosine distribution</a> in latitude for an equal area-weighted uniform distribution over the sphere</p><pre><code class="language-julia hljs">rand(Particle{Float32})         # specify number format
rand(Particle{Float32, true})   # and active/inactive
rand(Particle)                  # or not (defaults used instead)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Particle{Float32,   active}(167.38˚E,  37.69˚N, σ = 0.03)</code></pre><h2 id="Advecting-particles"><a class="docs-heading-anchor" href="#Advecting-particles">Advecting particles</a><a id="Advecting-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Advecting-particles" title="Permalink"></a></h2><p>The <a href="../functions/#SpeedyWeather.Particle"><code>Particle</code></a> type can be used inside vectors, e.g.</p><pre><code class="language-julia hljs">zeros(Particle{Float32}, 3)
rand(Particle{Float64}, 5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Particle{Float64}}:
 Particle{Float64,   active}(207.92˚E, -76.82˚N, σ = 0.55)
 Particle{Float64,   active}(114.71˚E,   0.97˚N, σ = 0.40)
 Particle{Float64,   active}(  1.55˚E, -51.92˚N, σ = 0.00)
 Particle{Float64,   active}( 42.96˚E, -50.28˚N, σ = 0.12)
 Particle{Float64,   active}( 58.91˚E,   0.49˚N, σ = 0.55)</code></pre><p>which is how particles are represented inside a SpeedyWeather <a href="../structure/#Simulation"><code>Simulation</code></a>. Note that we have not specified whether the particles inside these vectors are active (e.g. <code>Particle{Float32, true}</code>) or inactive (e.g. <code>Particle{Float64, false}</code>) because that would generally force all particles in these vectors to be either active or inactive as specified such that</p><pre><code class="language-julia hljs">v = zeros(Particle{Float32, false}, 3)
v[1] = Particle(lon = 134.0, lat = 23)      # conversion to inactive Particle{Float32, false}
v</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Particle{Float32, false}}:
 Particle{Float32, inactive}(134.00˚E,  23.00˚N, σ = 0.00)
 Particle{Float32, inactive}(  0.00˚E,   0.00˚N, σ = 0.00)
 Particle{Float32, inactive}(  0.00˚E,   0.00˚N, σ = 0.00)</code></pre><p>would not just convert from <code>Float64</code> to <code>Float32</code> but also from an active to an inactive particle. In SpeedyWeather all particles can be activated or deactivated at any time.</p><p>First, you create a <a href="../how_to_run_speedy/#SpectralGrid"><code>SpectralGrid</code></a> with the <code>n_particles</code> keyword</p><pre><code class="language-julia hljs">spectral_grid = SpectralGrid(n_particles = 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SpectralGrid:
├ Spectral:   T31 LowerTriangularMatrix{Complex{Float32}}, radius = 6.371e6 m
├ Grid:       48-ring OctahedralGaussianGrid{Float32}, 3168 grid points
├ Resolution: 401km (average)
├ Particles:  3
└ Vertical:   8-level SigmaCoordinates</code></pre><p>Then the particles live as <code>Vector{Particle}</code> inside the prognostic variables</p><pre><code class="language-julia hljs">model = BarotropicModel(;spectral_grid)
simulation = initialize!(model)
simulation.prognostic_variables.particles</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Particle{Float32}}:
 Particle{Float32,   active}( 86.18˚E, -51.34˚N, σ = 0.32)
 Particle{Float32,   active}(182.12˚E, -24.97˚N, σ = 0.12)
 Particle{Float32,   active}(236.11˚E,  18.56˚N, σ = 0.68)</code></pre><p>Which are placed in random locations (using <code>rand</code>) initially. In order to change these (e.g. to set the initial conditions) you do</p><pre><code class="language-julia hljs">simulation.prognostic_variables.particles[1] = Particle(lon=-120, lat=45)
simulation.prognostic_variables.particles</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Particle{Float32}}:
 Particle{Float32,   active}(-120.00˚E,  45.00˚N, σ = 0.00)
 Particle{Float32,   active}(182.12˚E, -24.97˚N, σ = 0.12)
 Particle{Float32,   active}(236.11˚E,  18.56˚N, σ = 0.68)</code></pre><p>which sets the first particle (you can think of the index as the particle identification) to some specified location, or you could deactivate a particle with</p><pre><code class="language-julia hljs">first_particle = simulation.prognostic_variables.particles[1]
simulation.prognostic_variables.particles[1] = deactivate(first_particle)
simulation.prognostic_variables.particles</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Particle{Float32}}:
 Particle{Float32, inactive}(-120.00˚E,  45.00˚N, σ = 0.00)
 Particle{Float32,   active}(182.12˚E, -24.97˚N, σ = 0.12)
 Particle{Float32,   active}(236.11˚E,  18.56˚N, σ = 0.68)</code></pre><p>To actually advect these particles inside a SpeedyWeather simulation we have to create a <code>ParticalAdvection2D</code> instance that lets you control the time step used for particle advection and which vertical layer to use in the 3D models.</p><pre><code class="language-julia hljs">particle_advection = ParticleAdvection2D(spectral_grid, layer = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ParticleAdvection2D{Float32} &lt;: SpeedyWeather.AbstractParticleAdvection
├ every_n_timesteps::Int64 = 8
├ layer::Int64 = 1
└ Δt::Base.RefValue{Float32} = Base.RefValue{Float32}(0.0f0)</code></pre><p>we choose the first (=top-most) layer although this is the default anyway. Now we can advect our three particles we have defined above</p><pre><code class="language-julia hljs">model = BarotropicModel(;spectral_grid, particle_advection)
simulation = initialize!(model)
simulation.prognostic_variables.particles</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Particle{Float32}}:
 Particle{Float32,   active}(281.54˚E,  32.71˚N, σ = 0.56)
 Particle{Float32,   active}(261.19˚E, -45.29˚N, σ = 0.02)
 Particle{Float32,   active}(  9.60˚E, -23.49˚N, σ = 0.56)</code></pre><p>Which are the initial conditions for our three particles. After 10 days of simulation they have changed</p><pre><code class="language-julia hljs">run!(simulation, period=Day(10))
simulation.prognostic_variables.particles</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Particle{Float32}}:
 Particle{Float32,   active}(289.93˚E,  31.94˚N, σ = 0.56)
 Particle{Float32,   active}(248.29˚E, -45.17˚N, σ = 0.02)
 Particle{Float32,   active}(357.70˚E, -23.47˚N, σ = 0.56)</code></pre><p>Woohoo! We just advected some particles. This is probably not as exciting as actually tracking the particles over the globe and being able to visualise their trajectory which we will do in the next section</p><h2 id="Tracking-particles"><a class="docs-heading-anchor" href="#Tracking-particles">Tracking particles</a><a id="Tracking-particles-1"></a><a class="docs-heading-anchor-permalink" href="#Tracking-particles" title="Permalink"></a></h2><p>A <a href="../functions/#SpeedyWeather.ParticleTracker"><code>ParticleTracker</code></a> is implemented as a callback, see <a href="../callbacks/#Callbacks">Callbacks</a>, outputting the particle locations via netCDF. We can create it like</p><pre><code class="language-julia hljs">using SpeedyWeather
spectral_grid = SpectralGrid(n_particles = 100)
particle_tracker = ParticleTracker(spectral_grid, schedule=Schedule(every=Hour(3)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ParticleTracker{Float32} &lt;: AbstractCallback
├ schedule::Schedule = Schedule &lt;: SpeedyWeather.AbstractSchedule
├ every::Second = 10800 seconds
├ steps::Int64 = 0
├ counter::Int64 = 0
└── arrays: times, schedule
├ file_name::String = particles.nc
├ compression_level::Int64 = 1
├ shuffle::Bool = false
├ keepbits::Int64 = 15
├ n_particles::Int64 = 100
├ netcdf_file::Nothing = nothing
└── arrays: lon, lat, σ</code></pre><p>which would output every 3 hours (the default). This output frequency might be slightly adjusted depending on the time step of the dynamics to output every <code>n</code> time steps (an <code>@info</code> is thrown if that is the case), see <a href="../callbacks/#Schedules">Schedules</a>. Further options on compression are available as keyword arguments <code>ParticleTracker(spectral_grid, keepbits=15)</code> for example. The callback is then added after the model is created</p><pre><code class="language-julia hljs">particle_advection = ParticleAdvection2D(spectral_grid)
model = ShallowWaterModel(;spectral_grid, particle_advection)
add!(model.callbacks, particle_tracker)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">[ Info: </span></span>ParticleTracker{Float32} callback added with key callback_61eC</code></pre><p>which will give it a random key too in case you need to remove it again (more on this in  <a href="../callbacks/#Callbacks">Callbacks</a>). If you now run the simulation the particle tracker is called on <code>particle_tracker.every_n_timesteps</code> and it continuously writes into <code>particle_tracker.netcdf_file</code> which is placed in the run folder similar to other <a href="../output/#NetCDF-output">NetCDF output</a>. For example, the run id can be obtained after the simulation by <code>model.output.id</code>.</p><pre><code class="language-julia hljs">simulation = initialize!(model)
run!(simulation, period=Day(10))
model.output.id</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;0005&quot;</code></pre><p>so that you can read the netCDF file with</p><pre><code class="language-julia hljs">using NCDatasets
run_id = &quot;run_$(model.output.id)&quot;                    # create a run_???? string with output id
path = joinpath(run_id, particle_tracker.file_name)  # by default &quot;run_????/particles.nc&quot;
ds = NCDataset(path)
ds[&quot;lon&quot;]
ds[&quot;lat&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32">lat</span> (100 × 81)
  Datatype:    <span class="sgr1">Float32</span> (Float32)
  Dimensions:  particle × time
  Attributes:
   units                = <span class="sgr36">degrees_east</span>
   long_name            = <span class="sgr36">latitude</span>
</code></pre><p>where the last two lines are lazy loading a matrix with each row a particle and each column a time step. You may do <code>ds[&quot;lon&quot;][:,:]</code> to obtain the full <code>Matrix</code>. We had specified <code>spectral_grid.n_particles</code> above and we will have time steps in this file depending on the <code>period</code> the simulation ran for and the <code>particle_tracker.Δt</code> output frequency. We can visualise the particles&#39; trajectories with</p><pre><code class="language-julia hljs">lon = ds[&quot;lon&quot;][:,:]
lat = ds[&quot;lat&quot;][:,:]
n_particles = size(lon,1)

using CairoMakie
fig = lines(lon[1, :], lat[1, :])                               # first particle only
[lines!(fig.axis, lon[i,:], lat[i,:]) for i in 2:n_particles]   # add lines for other particles

# display updated figure
fig</code></pre><p><img src="../particles.png" alt="Particle trajectories"/></p><p>Instead of providing a polished example with a nice projection we decided to keep it simple here because this is probably how you will first look at your data too. As you can see, some particles in the Northern Hemisphere have been advected with a zonal jet and perform some wavy motions as the jet does too. However, there are also some horizontal lines which are automatically plotted when a particles travels across the prime meridian 0˚E = 360˚E. Ideally you would want to use a more advanced projection and plot the particle trajectories as geodetics. </p><p>With <a href="https://github.com/MakieOrg/GeoMakie.jl">GeoMakie.jl</a> you can do</p><pre><code class="language-julia hljs">using GeoMakie, CairoMakie

fig = Figure()
ga = GeoAxis(fig[1, 1]; dest = &quot;+proj=ortho +lon_0=45 +lat_0=45&quot;)
[lines!(ga, lon[i,:], lat[i,:]) for i in 1:n_particles]
fig</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">WARNING: Method definition isfinite(Union{GeometryBasics.AbstractPoint{Dim, T} where T where Dim, GeometryBasics.Vec{S, T} where T where S}) in module GeometryBasics at /home/runner/.julia/packages/GeometryBasics/ebXl0/src/fixed_arrays.jl:134 overwritten in module GeoMakie at /home/runner/.julia/packages/GeoMakie/vcMuZ/src/utils.jl:128.
ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.</code></pre><p><img src="../particles_geomakie.png" alt="Particle advection"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../structure/">« Tree structure</a><a class="docs-footer-nextpage" href="../output/">NetCDF output »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 6 May 2024 22:45">Monday 6 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
