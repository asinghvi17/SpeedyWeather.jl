<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Callbacks · SpeedyWeather.jl</title><meta name="title" content="Callbacks · SpeedyWeather.jl"/><meta property="og:title" content="Callbacks · SpeedyWeather.jl"/><meta property="twitter:title" content="Callbacks · SpeedyWeather.jl"/><meta name="description" content="Documentation for SpeedyWeather.jl."/><meta property="og:description" content="Documentation for SpeedyWeather.jl."/><meta property="twitter:description" content="Documentation for SpeedyWeather.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpeedyWeather.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../barotropic/">Barotropic model</a></li><li><a class="tocitem" href="../shallowwater/">Shallow water model</a></li><li><a class="tocitem" href="../primitiveequation/">Primitive equation model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Physics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../large_scale_condensation/">Large-scale condensation</a></li><li><a class="tocitem" href="../convection/">Convection</a></li><li><a class="tocitem" href="../radiation/">Radiation</a></li><li><a class="tocitem" href="../vertical_diffusion/">Vertical diffusion</a></li><li><a class="tocitem" href="../surface_fluxes/">Surface fluxes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Discretization</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../spectral_transform/">Spherical Harmonic Transform</a></li><li><a class="tocitem" href="../grids/">Grids</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Running SpeedyWeather</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../how_to_run_speedy/">How to run SpeedyWeather</a></li><li><a class="tocitem" href="../examples_2D/">Examples 2D</a></li><li><a class="tocitem" href="../examples_3D/">Examples 3D</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../structure/">Tree structure</a></li><li><a class="tocitem" href="../particles/">Particle advection</a></li><li><a class="tocitem" href="../output/">NetCDF output</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">Extending SpeedyWeather</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../forcing_drag/">Forcing and drag</a></li><li><a class="tocitem" href="../parameterizations/">Parameterizations</a></li><li><a class="tocitem" href="../orography/">Orography</a></li><li><a class="tocitem" href="../land_sea_mask/">Land-Sea Mask</a></li><li><a class="tocitem" href="../ocean/">Ocean</a></li><li class="is-active"><a class="tocitem" href>Callbacks</a><ul class="internal"><li><a class="tocitem" href="#Defining-a-callback"><span>Defining a callback</span></a></li><li><a class="tocitem" href="#Adding-a-callback"><span>Adding a callback</span></a></li><li><a class="tocitem" href="#intrusive_callbacks"><span>Intrusive callbacks</span></a></li><li><a class="tocitem" href="#Schedules"><span>Schedules</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../ringgrids/">RingGrids</a></li><li><a class="tocitem" href="../lowertriangularmatrices/">LowerTriangularMatrices</a></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">SpeedyTransforms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../speedytransforms/">Spectral transforms</a></li><li><a class="tocitem" href="../gradients/">Gradient operators</a></li></ul></li><li><a class="tocitem" href="../functions/">Function and type index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Extending SpeedyWeather</a></li><li class="is-active"><a href>Callbacks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Callbacks</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SpeedyWeather/SpeedyWeather.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/main/docs/src/callbacks.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Callbacks"><a class="docs-heading-anchor" href="#Callbacks">Callbacks</a><a id="Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Callbacks" title="Permalink"></a></h1><p>SpeedyWeather.jl implements a callback system to let users include a flexible piece of code into the time stepping. You can think about the main time loop <em>calling back</em> to check whether anything else should be done before continuing with the next time step. The callback system here is called <em>after</em> the time step only (plus one call at <code>initialize!</code> and one at <code>finish!</code>), we currently do not implement other callsites.</p><p>Callbacks are mainly introduced for diagnostic purposes, meaning that they do not influence the simulation, and access the prognostic variables and the model components in a read-only fashion. However, a callback is not strictly prevented from changing prognostic or diagnostic variables or the model. For example, you may define a callback that changes the orography during the simulation. In general, one has to keep the general order of executions during a time step in mind (valid for all models)</p><ol><li>set tendencies to zero</li><li>compute parameterizations, forcing, or drag terms. Accumulate tendencies.</li><li>compute dynamics, accumulate tendencies.</li><li>time stepping</li><li>output</li><li>callbacks</li></ol><p>This means that, at the current callsite, a callback can read the tendencies but writing into it would be overwritten by the zeroing of the tendencies in 1. anyway. At the moment, if a callback wants to implement an additional tendency then it currently should be implemented as a parameterization, forcing or drag term. </p><h2 id="Defining-a-callback"><a class="docs-heading-anchor" href="#Defining-a-callback">Defining a callback</a><a id="Defining-a-callback-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-callback" title="Permalink"></a></h2><p>You can (and are encouraged!) to write your own callbacks to diagnose SpeedyWeather simulations. Let us implement a <code>StormChaser</code> callback, recording the highest surface wind speed on every time step, that we want to use to illustrate how a callback needs to be defined.</p><p>Every custom callback needs to be defined as a (<code>mutable</code>) <code>struct</code>, subtype of <code>AbstractCallback</code>, i.e. <code>struct</code> or <code>mutable struct CustomCallback &lt;: SpeedyWeather.AbstractCallback</code>. In our case, this is</p><pre><code class="language-julia hljs">using SpeedyWeather

Base.@kwdef mutable struct StormChaser{NF} &lt;: SpeedyWeather.AbstractCallback
    timestep_counter::Int = 0
    maximum_surface_wind_speed::Vector{NF} = [0]
end

# Generator function
StormChaser(SG::SpectralGrid) = StormChaser{SG.NF}()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.StormChaser</code></pre><p>We decide to have a field <code>timestep_counter</code> in the callback that allows us to track the number of times the callback was called to create a time series of our highest surface wind speeds. The actual <code>maximum_surface_wind_speed</code> is then a vector of a given type <code>NF</code> (= number format), which is where we&#39;ll write into. Both are initialised with zeros. We also add a generator function, similar as to many other components in SpeedyWeather that just pulls the number format from the <code>SpectralGrid</code> object.</p><p>Now every callback needs to extend three methods</p><ol><li><code>initialize!</code>, called once before the main time loop starts</li><li><code>callback!</code>, called after every time step</li><li><code>finish!</code>, called once after the last time step</li></ol><p>And we&#39;ll go through them one by one.</p><pre><code class="language-julia hljs">function SpeedyWeather.initialize!(
    callback::StormChaser,
    progn::PrognosticVariables,
    diagn::DiagnosticVariables,
    model::ModelSetup,
)
    # allocate recorder: number of time steps (incl initial conditions) in simulation
    callback.maximum_surface_wind_speed = zeros(progn.clock.n_timesteps + 1)

    # where surface (=lowermost model layer) u, v on the grid are stored
    (; u_grid, v_grid) = diagn.layers[diagn.nlev].grid_variables

    # maximum wind speed of initial conditions
    callback.maximum_surface_wind_speed[1] = max_2norm(u_grid, v_grid)

    # (re)set counter to 1
    callback.timestep_counter = 1
end</code></pre><p>The <code>initialize!</code> function has to be extended for the new callback <code>::StormChaser</code> as first argument, then followed by prognostic and diagnostic variables and model. For correct multiple dispatch it is important to restrict the first argument to the new <code>StormChaser</code> type (to not call another callback instead), but the other type declarations are for clarity only. <code>initialize!(::AbstractCallback, args...)</code> is called once just before the main time loop, meaning after the initial conditions are set and after all other components are initialized. We replace the vector inside our storm chaser with a vector of the correct length so that we have a &quot;recorder&quot; allocated, a vector that can store the maximum surface wind speed on every time step. We then also compute that maximum for the initial conditions and set the time step counter to 1. We define the <code>max_2norm</code> function as follows</p><pre><code class="language-julia hljs">&quot;&quot;&quot;Maximum of the 2-norm of elements across two arrays.&quot;&quot;&quot;
function max_2norm(u::AbstractArray{T}, v::AbstractArray{T}) where T
    max_norm = zero(T)      # = u² + v²
    for ij in eachindex(u, v)
        # find largest wind speed squared
        max_norm = max(max_norm, u[ij]^2 + v[ij]^2)
    end
    return sqrt(max_norm)   # take sqrt only once
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.max_2norm</code></pre><p>Note that this function is defined in the scope <code>Main</code> and not inside SpeedyWeather, this is absolutely possible due to Julia&#39;s scope of variables which will use <code>max_2norm</code> from <code>Main</code> scope if it doesn&#39;t exist in the global scope inside the <code>SpeedyWeather</code> module scope. Then we need to extend the <code>callback!</code> function as follows</p><pre><code class="language-julia hljs">function SpeedyWeather.callback!(
    callback::StormChaser,
    progn::PrognosticVariables,
    diagn::DiagnosticVariables,
    model::ModelSetup,
)

    # increase counter
    callback.timestep_counter += 1
    i = callback.timestep_counter

    # where surface (=lowermost model layer) u, v on the grid are stored
    (; u_grid, v_grid) = diagn.layers[diagn.nlev].grid_variables

    # maximum wind speed at current time step
    callback.maximum_surface_wind_speed[i] = max_2norm(u_grid, v_grid)
end</code></pre><p>The function signature for <code>callback!</code> is the same as for <code>initialize!</code>. You may access anything from <code>progn</code>, <code>diagn</code> or <code>model</code>, although for a purely diagnostic callback this should be read-only. While you could change other model components like the land sea mask in <code>model.land_sea_mask</code> or orography etc. then you interfere with the simulation which is more advanced and will be discussed in Intrusive callbacks below.</p><p>Lastly, we extend the <code>finish!</code> function which is called once after the last time step. This could be used, for example, to save the <code>maximum_surface_wind_speed</code> vector to file or in case you want to find the highest wind speed across all time steps. But in many cases you may not need to do anything, in which case you just just let it return <code>nothing</code>.</p><pre><code class="language-julia hljs">SpeedyWeather.finish!(::StormChaser, args...) = nothing</code></pre><div class="admonition is-info"><header class="admonition-header">Always extend `initialize!`, `callback!` and `finish!`</header><div class="admonition-body"><p>For a custom callback you need to extend all three, <code>initialize!</code>, <code>callback!</code> and <code>finish!</code>, even if your callback doesn&#39;t need it. Just return <code>nothing</code> in that case. Otherwise a <code>MethodError</code> will occur. While we could have defined all callbacks by default to do nothing on each of these, this may give you the false impression that your callback is already defined correctly, although it&#39;s not.</p></div></div><h2 id="Adding-a-callback"><a class="docs-heading-anchor" href="#Adding-a-callback">Adding a callback</a><a id="Adding-a-callback-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-callback" title="Permalink"></a></h2><p>Every model has a field <code>callbacks::Dict{Symbol, AbstractCallback}</code> such that the <code>callbacks</code> keyword can be used to create a model with a dictionary of callbacks. Callbacks are identified with a <code>Symbol</code> key inside such a dictionary. We have a convenient <code>CallbackDict</code> generator function which can be used like <code>Dict</code> but the key-value pairs have to be of type <code>Symbol</code>-<code>AbstractCallback</code>. Let us illustrate this with the dummy callback <code>NoCallback</code> (which is a callback that returns <code>nothing</code> on <code>initialize!</code>, <code>callback!</code> and <code>finish!</code>)</p><pre><code class="language-julia hljs">callbacks = CallbackDict()                                  # empty dictionary
callbacks = CallbackDict(:my_callback =&gt; NoCallback())      # key =&gt; callback</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, SpeedyWeather.AbstractCallback} with 1 entry:
  :my_callback =&gt; NoCallback &lt;: AbstractCallback…</code></pre><p>If you don&#39;t provide a key a random key will be assigned</p><pre><code class="language-julia hljs">callbacks = CallbackDict(NoCallback())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, SpeedyWeather.AbstractCallback} with 1 entry:
  :callback_DHYc =&gt; NoCallback &lt;: AbstractCallback…</code></pre><p>and you can add (or delete) additional callbacks</p><pre><code class="language-julia hljs">add!(callbacks, NoCallback())                   # this will also pick a random key
add!(callbacks, :my_callback =&gt; NoCallback())   # use key :my_callback
delete!(callbacks, :my_callback)                # remove by key
callbacks</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, SpeedyWeather.AbstractCallback} with 2 entries:
  :callback_DHYc =&gt; NoCallback &lt;: AbstractCallback…
  :callback_F8RG =&gt; NoCallback &lt;: AbstractCallback…</code></pre><p>And you can chain them too</p><pre><code class="language-julia hljs">add!(callbacks, NoCallback(), NoCallback())                     # random keys
add!(callbacks, :key1 =&gt; NoCallback(), :key2 =&gt; NoCallback())   # keys provided</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">[ Info: </span></span>NoCallback callback added with key callback_qRL6
<span class="sgr36"><span class="sgr1">[ Info: </span></span>NoCallback callback added with key callback_OlEh</code></pre><p>Meaning that callbacks can be added before and after model construction</p><pre><code class="language-julia hljs">spectral_grid = SpectralGrid()
callbacks = CallbackDict(:callback_added_before =&gt; NoCallback())
model = PrimitiveWetModel(; spectral_grid, callbacks)
add!(model.callbacks, :callback_added_afterwards =&gt; NoCallback())
add!(model, :callback_added_afterwards2 =&gt; NoCallback())</code></pre><p>Note how the first argument can be <code>model.callbacks</code> as outlined in the sections above because this is the callbacks dictionary, but also simply <code>model</code>, which will add the callback to <code>model.callbacks</code>. It&#39;s equivalent. Let us add two more meaningful callbacks</p><pre><code class="language-julia hljs">storm_chaser = StormChaser(spectral_grid)
record_surface_temperature = GlobalSurfaceTemperatureCallback(spectral_grid)
add!(model.callbacks, :storm_chaser =&gt; storm_chaser)
add!(model.callbacks, :temperature =&gt; record_surface_temperature)</code></pre><p>which means that now in the calls to <code>callback!</code> first the two dummy <code>NoCallback</code>s are called and then our storm chaser callback and then the <code>GlobalSurfaceTemperatureCallback</code> which records the global mean surface temperature on every time step. From normal <a href="../output/#NetCDF-output">NetCDF output</a> the information these callbacks analyse would not be available, only at the frequency of the model output, which for every time step would create way more data and considerably slow down the simulation. Let&#39;s run the simulation and check the callbacks</p><pre><code class="language-julia hljs">simulation = initialize!(model)
run!(simulation, period=Day(3))
v = model.callbacks[:storm_chaser].maximum_surface_wind_speed
maximum(v)      # highest surface wind speeds in simulation [m/s]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">54.68433f0</code></pre><p>Cool, our <code>StormChaser</code> callback with the key <code>:storm_chaser</code> has been recording maximum surface wind speeds in [m/s]. And the <code>:temperature</code> callback a time series of global mean surface temperatures in Kelvin on every time step while the model ran for 3 days.</p><pre><code class="language-julia hljs">model.callbacks[:temperature].temp</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">145-element Vector{Float32}:
 285.2934
 284.13998
 283.41168
 282.58765
 282.1953
 281.57895
 281.33258
 280.87823
 280.86374
 280.43573
   ⋮
 284.4084
 283.20288
 284.3765
 283.2464
 284.34818
 283.2993
 284.32663
 283.36108
 284.31247</code></pre><h2 id="intrusive_callbacks"><a class="docs-heading-anchor" href="#intrusive_callbacks">Intrusive callbacks</a><a id="intrusive_callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#intrusive_callbacks" title="Permalink"></a></h2><p>In the sections above, callbacks were introduced as a tool to define custom diagnostics or simulation output. This is the simpler and recommended way of using  them but nothing stops you from defining a callback that is <em>intrusive</em>, meaning that it can alter the prognostic or diagnostic variables or the model.</p><p>Changing any components of the model, e.g. boundary conditions like orography or the land-sea mask through a callback is possible although one should notice that this only comes into effect on the next time step given the execution order mentioned above. One could for example run a simulation for a certain period and then start moving continents around. Note that for physical consistency this should be reflected in the orography, land-sea mask, as well as in the available sea and land-surface temperatures, but one is free to do this only partially too. Another example would be to switch on/off certain model components over time. If these components are implemented as <em>mutable</em> struct then one could define a callback that weakens their respective strength parameter over time.</p><p>As an example of a callback that changes the model components see</p><ul><li>Millenium flood: <a href="../land_sea_mask/#Time-dependent-land-sea-mask">Time-dependent land-sea mask</a></li></ul><p>Changing the diagnostic variables, however, will not have any effect. All of them are treated as work arrays, meaning that their state is completely overwritten on every time step.  Changing the prognostic variables in spectral space directly is not advised though possible because this can easily lead to stability issues. It is generally easier to implement something like this as a parameterization, forcing or drag term (which can also be made time-dependent).</p><p>Overall, callbacks give the user a wide range of possibilities to diagnose  the simulation while running or to interfere with a simulation. We therefore encourage users to use callbacks as widely as possible, but if you run into any issues please open an issue in the repository and explain what you&#39;d like to achieve and which errors you are facing. We are happy to help.</p><h2 id="Schedules"><a class="docs-heading-anchor" href="#Schedules">Schedules</a><a id="Schedules-1"></a><a class="docs-heading-anchor-permalink" href="#Schedules" title="Permalink"></a></h2><p>For convenience, SpeedyWeather.jl implements a <a href="../functions/#SpeedyWeather.Schedule"><code>Schedule</code></a> which helps to schedule when callbacks are called. Because in many situations you don&#39;t want to call them on every time step but only periodically, say once a day, or only on specific dates and times, e.g. Jan 1 at noon. Several examples how to create schedules</p><pre><code class="language-julia hljs">using SpeedyWeather

# execute on timestep at or after Jan 2 2000
event_schedule = Schedule(DateTime(2000,1,2))

# several events scheduled
events = (DateTime(2000,1,3), DateTime(2000,1,5,12))
several_events_schedule = Schedule(events...)

# provided as Vector{DateTime} with times= keyword
always_at_noon = [DateTime(2000,1,i,12) for i in 1:10]
noon_schedule = Schedule(times=always_at_noon)

# or using every= for periodic execution, here once a day
periodic_schedule = Schedule(every=Day(1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Schedule &lt;: SpeedyWeather.AbstractSchedule
├ every::Second = 86400 seconds
├ steps::Int64 = 0
├ counter::Int64 = 0
└── arrays: times, schedule</code></pre><p>A <code>Schedule</code> has 5 fields, see <a href="../functions/#SpeedyWeather.Schedule"><code>Schedule</code></a>. <code>every</code> is an option to create a periodic schedule to execute every time that indicated period has passed. <code>steps</code> and <code>counter</code> will let you know how many callback execution steps there are and count them up. <code>times</code> is a  <code>Vector{DateTime}</code> containing scheduled events. <code>schedule</code> is the actual schedule inside a <code>Schedule</code>, implemented as <code>BitVector</code> indicating whether to execute on a given time step (<code>true</code>) or not (<code>false</code>).</p><p>Let&#39;s show how to use a <code>Schedule</code> inside a callback</p><pre><code class="language-julia hljs">struct MyScheduledCallback &lt;: SpeedyWeather.AbstractCallback
    schedule::Schedule
    # add other fields here that you need
end

function SpeedyWeather.initialize!(
    callback::MyScheduledCallback,
    progn::PrognosticVariables,
    args...
)
    # when initializing a scheduled callback also initialize its schedule!
    initialize!(callback.schedule, progn.clock)

    # initialize other things in your callback here
end

function SpeedyWeather.callback!(
    callback::MyScheduledCallback,
    progn::PrognosticVariables,
    diagn::DiagnosticVariables,
    model::ModelSetup,
)
    # scheduled callbacks start with this line to execute only when scheduled!
    # else escape immediately
    isscheduled(callback.schedule, progn.clock) || return nothing

    # Just print the North Pole surface temperature to screen
    (;time) = progn.clock
    temp_at_north_pole = diagn.layers[end].grid_variables.temp_grid[1]
    @info &quot;North pole has a temperature of $temp_at_north_pole on $time.&quot;
end

# nothing needs to be done when finishing
SpeedyWeather.finish!(::MyScheduledCallback, args...) = nothing</code></pre><p>So in summary</p><ul><li>add a field <code>schedule::Schedule</code> to your callback</li><li>add the line <code>initialize!(callback.schedule, progn.clock)</code> when initializing your callback</li><li>start your <code>callback!</code> method with <code>isscheduled(callback.schedule, progn.clock) || return nothing</code> to execute only when scheduled</li></ul><p>A <code>Schedule</code> is a field inside a callback as this allows you the set the callbacks desired schedule when creating it. In the example above we can create our callback that is supposed to print the North Pole&#39;s temperature like so</p><pre><code class="language-julia hljs">north_pole_temp_at_noon_jan9 = MyScheduledCallback(Schedule(DateTime(2000,1,9,12)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.MyScheduledCallback &lt;: AbstractCallback
└ schedule::Schedule = Schedule &lt;: SpeedyWeather.AbstractSchedule
├ every::Second = 9223372036854775807 seconds
├ steps::Int64 = 0
├ counter::Int64 = 0
└── arrays: times, schedule</code></pre><p>The default for <code>every</code> is <code>typemax(Int)</code> indicating &quot;never&quot;. This just means that there is no periodically reoccuring schedule, only <code>schedule.times</code> would include some times for events that are scheduled. Now let&#39;s create a primitive equation model with that callback</p><pre><code class="language-julia hljs">spectral_grid = SpectralGrid(trunc=31, nlev=5)
model = PrimitiveWetModel(;spectral_grid)
model.feedback.verbose = false      # hide to progress meter
add!(model.callbacks, north_pole_temp_at_noon_jan9)

# start simulation 7 days earlier
simulation = initialize!(model, time = DateTime(2000,1,2,12))
run!(simulation, period=Day(10))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Main.MyScheduledCallback callback added with key callback_IP4N
<span class="sgr36"><span class="sgr1">[ Info: </span></span>North pole has a temperature of 225.02998 on 2000-01-09T12:00:00.</code></pre><p>So the callback gives us the temperature at the North Pole exactly when scheduled. We could have also stored this temperature, or conditionally changed parameters inside the model. There are plenty of ways how to use the scheduling, either by event, or in contrast, we could also schedule for once a day. As illustrated in the following</p><pre><code class="language-julia hljs">north_pole_temp_daily = MyScheduledCallback(Schedule(every=Day(1)))
add!(model.callbacks, north_pole_temp_daily)

# resume simulation, start time is now 2000-1-12 noon
run!(simulation, period=Day(5))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Main.MyScheduledCallback callback added with key callback_JpVA
<span class="sgr33"><span class="sgr1">┌ Warning: </span></span>Empty schedule.
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ SpeedyWeather ~/work/SpeedyWeather.jl/SpeedyWeather.jl/src/output/schedule.jl:77</span>
<span class="sgr36"><span class="sgr1">[ Info: </span></span>North pole has a temperature of 257.99673 on 2000-01-13T12:00:00.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>North pole has a temperature of 260.83414 on 2000-01-14T12:00:00.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>North pole has a temperature of 258.1956 on 2000-01-15T12:00:00.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>North pole has a temperature of 255.35739 on 2000-01-16T12:00:00.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>North pole has a temperature of 250.48715 on 2000-01-17T12:00:00.</code></pre><p>Note that the previous callback is still part of the model, we haven&#39;t deleted it with <code>delete!</code>. But because it&#39;s scheduled for a specific time that&#39;s in the past now that we resume the simulation it&#39;s schedule is empty (which is thrown as a warning). However, our new callback, scheduled daily, is active and prints daily at noon, because the simulation start time was noon.</p><h3 id="Scheduling-logic"><a class="docs-heading-anchor" href="#Scheduling-logic">Scheduling logic</a><a id="Scheduling-logic-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduling-logic" title="Permalink"></a></h3><p>An event <code>Schedule</code> (created with <code>DateTime</code> object(s)) for callbacks, executes  on or after the specified times. For two consecutive time steps <span>$i$</span>, <span>$i+1$</span>, an event is scheduled at <span>$i+1$</span> when it occurs in <span>$(i,i+1]$</span>. So a simulation with timestep <code>i</code> on Jan-1 at 1am, and <span>$i+1$</span> at 2am, will execute a callback scheduled for 1am at <span>$i$</span> but scheduled for 1am and 1s (=01:00:01 on a 24H clock) at 2am. Because callbacks are always executed <em>after</em> a timestep this also means that a simulation starting at midnight with a callback scheduled for midnight will not execute this callback as it is outside of the <span>$(i, i+1]$</span> range. You&#39;d need to include this execution into the initialization. If several events inside the <code>Schedule</code> fall into the same time step (in the example above, 1am and 1s and 1am 30min) the execution will not happen twice. Think of a scheduled callback as a binary &quot;should the callback be executed now or not?&quot;. Which is in fact how it&#39;s implemented, as a <code>BitVector</code> of the length of the number of time steps. If the bit at a given timestep is true, execute, otherwise not.</p><p>A periodic <code>Schedule</code> (created with <code>every = Hour(2)</code> or similar) will execute on the timestep <em>after</em> that period (here 2 hours) has passed. If a simulation starts at midnight with one hour time steps then execution would take place after the timestep from 1am to 2am because that&#39;s when the clock switches to 2am which is 2 hours after the start of the simulation. Note that therefore the initial timestep is not included, however, the last time step would be if the period is a multiple of the scheduling period. If the first timestep should be included (e.g. you want to do something with the initial conditions) then you&#39;ll need to include that into the initialization of the callback.</p><p>Periodic schedules which do not match the simulation time step will be adjusted by rounding. Example, if you want a schedule which executes every hour but your simulation time step is 25min then it will be adjusted to execute every 2nd time step, meaning every 50min and not 1 hour. However, an info will be thrown if that is the case</p><pre><code class="language-julia hljs">odd_schedule = MyScheduledCallback(Schedule(every = Minute(70)))
add!(model.callbacks, odd_schedule)

# resume simulation for 4 hours
run!(simulation, period=Hour(4))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Main.MyScheduledCallback callback added with key callback_gC4r
<span class="sgr33"><span class="sgr1">┌ Warning: </span></span>Empty schedule.
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ SpeedyWeather ~/work/SpeedyWeather.jl/SpeedyWeather.jl/src/output/schedule.jl:77</span>
<span class="sgr33"><span class="sgr1">┌ Warning: </span></span>Empty schedule.
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ SpeedyWeather ~/work/SpeedyWeather.jl/SpeedyWeather.jl/src/output/schedule.jl:77</span>
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Scheduler adjusted from every 1 hour, 10 minutes to every 1 hour to match timestep.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>North pole has a temperature of 250.34338 on 2000-01-17T13:00:00.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>North pole has a temperature of 250.07698 on 2000-01-17T14:00:00.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>North pole has a temperature of 249.81987 on 2000-01-17T15:00:00.
<span class="sgr36"><span class="sgr1">[ Info: </span></span>North pole has a temperature of 249.56827 on 2000-01-17T16:00:00.</code></pre><p>Now we get two empty schedules, one from callback that&#39;s supposed to execute on Jan 9 noon (this time has passed in our simulation) and one from the daily callback (we&#39;re not simulating for a day). You could just <code>delete!</code> those callbacks. You can see that while we wanted our <code>odd_schedule</code> to execute every 70min, it has to adjust it to every 60min to match the simulation time step of 30min.</p><p>After the model initialization you can always check the simulation time step from <code>model.time_stepping</code> </p><pre><code class="language-julia hljs">model.time_stepping</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Leapfrog{Float32} &lt;: SpeedyWeather.AbstractTimeStepper
├ trunc::Int64 = 31
├ Δt_at_T31::Second = 1800 seconds
├ radius::Float32 = 6.371e6
├ adjust_with_output::Bool = true
├ robert_filter::Float32 = 0.05
├ williams_filter::Float32 = 0.53
├ Δt_millisec::Dates.Millisecond = 1800000 milliseconds
├ Δt_sec::Float32 = 1800.0
└ Δt::Float32 = 0.0002825302</code></pre><p>Or converted into minutes (the time step internally is at millisecond accuracy)</p><pre><code class="language-julia hljs">Minute(model.time_stepping.Δt_millisec)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">30 minutes</code></pre><p>which illustrates why the adjustment of our callback frequency was necessary.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ocean/">« Ocean</a><a class="docs-footer-nextpage" href="../ringgrids/">RingGrids »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 6 May 2024 22:45">Monday 6 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
